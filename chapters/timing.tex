\chapter{TIMING ANALYSIS}
\label{chap:timing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Packet detection}

Timing analysis is used to determine the point in time where the packet starts.
This is also a method to recognize \emph{whether} a packet has arrived or not.
In the current scheme, the packet detection module uses the Schmidl and Cox %(TODO: Put citation here)
method for timing analysis.

This entire section will assume a level of abstraction wherein we have an
inexhaustible data source of digital, complex symbols at the receiver. We
acquire this data by reading from this source into a buffer (which is simply an
array) in our receiver program's source code.

\subsection{The Schmidl and Cox algorithm}

For the receiver to be able to pick out a packet from ambient noise and
interference, the transmitted packet must be designed for detection. All
transmitted packets have a \emph{preamble}, which consists of two identical
halves. Each half is a pseudo-random-number sequence. The correlation of each
half with with other (independent and hence uncorrelated) signals is expected
to be low. However, its correlation with the other half will be high. Moreover,
this property is well-maintained even when the preamble is passed through an
ISI channel with additive white gaussian noise.

In other words, we can detect the start of a packet by correlating two adjacent
windows, each having half the size of the preamble, with each other. The point
where this correlation value becomes high can be taken to be the start of the
packet.

% TODO: Insert plot of preamble (real and imaginary) here
% TODO: Insert a picture of the two windows correlating received data

The metric used to determine whether or not the correlation value is high
enough is the normalized cross-correlation, defined as
$$ \text{Metric} = \frac{|\text{ Cross-correlation of the two windows }|^2}
                        {\text{Product of the autocorrelations of the windows}}
$$

% TODO: Insert a picture of the metric over the data

\subsection{Running correlation on the receive buffer}

In order to efficiently perform a running correlation of adjacent windows over
an entire receive buffer, we minimize the number of computations performed. On
moving one step, we add the latest correlation point and subtract the oldest
correlation point.

Let $\ue{x}$ and $\ue{y}$ be complex vectors corresponding to the symbols in
the left half-window and the right-half-window respectively. Let $n$ be the
half-window size. After moving one time step, let these windows be denoted by
the complex vectors $u$ and $v$ respectively.  We thus have $u_i = x_{i+1}$ and
$v_i = y_{i+1}$ for $i = {1, 2, \ldots n-1}$.

Let $c_{old}$ be the correlation of $x$ with $y$, and $c_{new}$ be the
correlation of $u$ with $v$. That is,
$$ c_{old} = \corr{\ue{x}}{\ue{y}} = \sum_1^n{\corr{x_i}{y_i}} $$
$$ c_{new} = \corr{\ue{u}}{\ue{v}} = \sum_1^n{\corr{u_i}{v_i}} $$
where $^*$ denotes complex conjugation. We can then write $c_{new}$ in terms of
$c_{old}$ as follows:
\begin{align}
	c_{new} &= \sum_1^{n-1}{\corr{u_i}{v_i}} + \corr{u_n}{v_n} \\
	        &= \sum_2^n{\corr{x_i}{y_i}} + \corr{u_n}{v_n} \\
	        &= \sum_1^n{\corr{x_i}{y_i}} - \corr{x_1}{y_1} + \corr{u_n}{v_n} \\
	        &= c_{old} - \corr{x_1}{y_1} + \corr{u_n}{v_n}
\end{align}

This way, once we have acquired the correlation of the first $n$ symbols, the
correlation of subsequent windows is an $\mathcal{O}(1)$ process.

\subsection{Implementation using the two-frame block}
\label{subsec:two-frame-impl}

In order to implement the Schmidl and Cox algorithm, we need to continuously
scan through the received symbols, correlating two windows, each half the size
of the preamble. Once the preamble is found, we need to pull out a full
\verb+frame_size+ number of symbols from the buffer.

Obviously, the receive buffer should be at least as long as the preamble. But
if the receive buffer is too long, then depending upon the rate of
communication, we may be adding latency to our program by having to wait for
the buffer to get filled. If our receive buffer is only one \verb+frame_size+
long, then on finding the preamble in the middle of this buffer, we will have
to take into account how many symbols more we need to extract for the frame
from the next buffer. This is cumbersome and error-prone.

A simpler implementation scheme involves having a receive buffer that is two
\verb+frame_size+s long. We refer to this buffer as the \emph{two-frame block}.
On each iteration, we search only the first half of the buffer. Even if the
preamble is found towards the end of the first half, we can still pull out a
full \verb+frame_size+ from the two-frame block.

%TODO: Insert picture of two-frame block along with the correlating windows.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The DC offset problem}

\subsection{Discovering the DC offset}
\subsection{Eliminating the DC offset}
\subsection{Running correlations with DC offset elimination}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Practical considerations}

\subsection{Cross-correlation cut-off for noisy regions}

We expect the absolute value of the cross-correlation of the two windows to be
much lower than the product of their autocorrelations. However, we found that
the value of the metric tended at times to be quite large, and even comparable
to the threshold used to determine the presence of a packet.

A possible reason for this might be the accumulation of errors due to the
running correlation algorithm being employed. In the regions of noise, both the
autocorrelation and cross-correlation values are low, however, random
fluctuations in the noise and in the error could sometimes cause them to become
roughly of the same order of magnitude.

In order to prevent erroneous packet detection in noisy regions, we introduced
a cut-off based on the absolute value of the cross-correlation. This cut-off
value must be empirically determined. If the absolute value of the
cross-correlation is less that the cut-off, we manually set the running
cross-correlation at the point to be zero, and skip all other checks for the
packet.

%TODO: Put pseudocode / actual code snippet here

\subsection{Violation of Cauchy-Schwarz inequality}
\label{subsec:cs-violation}

We discovered that at certain instances, for example when searching for the
preamble towards the end of a previous frame, the value of the metric exceeded
unity. In a strict mathematical sense, this is impossible, since
cross-correlation is an inner product operation, and the Cauchy-Schwarz
inequality guarantees that
$$ \langle \ue{u}, \ue{v} \rangle ^2 \leqslant |\ue{u}||\ue{v}| $$
Nevertheless, the situation was observed. On closer inspection, we found that
at the edge of the frame, the values of the complex symbols dropped rapidly. In
such a situation, it took time for the cross-correlation value to settle (time
for the accumulated errors to diminish in comparison to the cross-correlation
value itself), whereas the autocorrelation values settled faster. This caused
the cross-correlation value to exceed the autocorrelation product, thus giving
a metric value greater than unity.

When checking for the preamble itself, we gave allowances for errors causing
the metric value to exceed unity. But in the situation described above, this
occurred with far larger deviations than we might expect due purely to floating
point error. In fact, the error was the accumulated error in the algorithm
itself. In such situations also, we manually set the cross-correlation value to
zero to avoid further propagation of this error.

%TODO: Insert code snippet

\subsection{Fine metric}
\label{subsec:fine-metric}

When searching for the preamble in the body of a previous frame, we sometimes
found that the value of the metric exceeded the threshold. Essentially, the
values of the complex symbols within the frame depends on the data being
transmitted. It might so happen that the data produces a short repeating
pattern of the same length as the preamble in the bulk of the frame. In such a
situation, the timing synchronizer will erroneously detect a packet in the
middle of a frame.

This is because, so far, we have only correlated the first half of the preamble
with the second half in the received vector. We never correlated the received
symbols with the actual preamble values themselves (which are fixed, and thus
known at the receiver). It may not be possible to simply increase the threshold
until this stops happening, since the threshold value is determined by the
amount of noise in the system. %TODO: Insert ref to appendix with tuning.

To fix this issue, the fine metric is computed by correlating the first window
with the first half of the expected preamble. This is only done when the coarse
metric exceeds the threshold, since it is an expensive operation and since we
cannot use a running correlation algorithm to compute it. The fine metric value
has its own threshold, which is used as a second-pass for ensuring the presence
of an authentic preamble.

Note that even in the presence of an ISI channel, the fine metric will pick up
the most dominant channel tap. If $\ue{p}$ is the preamble vector and $\ue{h}$
is the channel, then the received preamble is
$$\ue{y} = \ue{p} * \ue{h}$$
This received vector is now correlated with the preamble itself, so that the
fine metric peaks at $\text{argmax}(\ue{h})$ with a peak value of
$\text{max}(\ue{h})$.

%TODO: Insert fine metric plot

\subsection{Going left for safety}
\label{subsec:safety}

In the event that the packet location as determined by the timing synchronizer
is not exactly correct, or in the event that there are several dominant taps
in the channel impulse response, we may not extract a good OFDM block. That is,
the OFDM block extracted may be polluted by the cyclic prefix of the subsequent
block. Such pollution cannot be corrected for by OFDM.

Therefore, to be \emph{safe}, we introduced a \verb+safety+ parameter. When
supplying the final packet location, we shift the packet \verb+safety+
positions to the left. This ensures that each OFDM block extracted will contain
only its own symbols. Instead of picking up symbols from the next block, we
would pick up symbols of the cyclic prefix of the same block. This can then be
corrected for by performing integer frequency offset estimation, in order to
rotate the block suitably.

The final location of the packet that is returned is therefore \\
\verb|        packet_loc = peak_index + preamble_length - safety|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Further optimizations}

On profiling the program, it was found that the timing synchronizer was the
slowest block, taking up to 50\% of the receiver program's run time. In order
to speed up the timing synchronizer to the extent possible, therefore, a few
more optimizations were performed that focused on reducing the amount of work
the timing synchronizer had to do.

\subsection{Stopping correlation after threshold breach}

The first optimization relies on the accuracy of the currently used timing
analysis algorithm. We found that the algorithm is quite selective in picking
out packets correctly. Given that this is the case, we assume that once the
fine metric threshold has been breached, a packet has been found, and that we
only need to find the dominant channel tap to find the best `location' of the
preamble.

Therefore, once the fine metric has been breached, we continue correlating only
up to a number \verb+max_time_steps_after_threshold+ of time steps. After this,
the point of maximum correlation is returned as the packet's location.

\subsection{Discarding the found frame block}

Once a preamble has been found in the two-frame block, we know that a full
frame follows. All symbols corresponding to this frame can then be removed from
the receive buffer so that we do not search what we know is part of a frame.

This way, we also (mostly) avoid the problems mentioned in
subsections~\ref{subsec:cs-violation} and~\ref{subsec:fine-metric}. Otherwise,
we would always have to scan the entirety of the second window, parts of which
might contain the frame body. Note that we do not entirely avoid this problem.
In the presence of an ISI channel, the effective frame length is longer than
one \verb+frame_size+, and in the event that the preamble is found at the end
of the first window, it is possible that the frame edge goes outside of the
second frame window, meaning parts of the frame would be yet to be received
into the 2-frame buffer. The other scenario where we may scan the bulk of the
frame in search of a packet is when the timing synchronizer fails to detet a
frame that is actually preset. In both these cases, we would encounter symbols
from the bulk of the frame, and thus the measures taken in
subsections~\ref{subsec:cs-violation} and~\ref{subsec:fine-metric} cannot be
done away with.

%TODO: Insert picture of two-frame block with frame guards and num_to_acquire
%      and num_left_to_search marked out

We had remarked in subsection~\ref{subsec:two-frame-impl} that a one-frame
block is cumbersome and error-prone, since it is difficult to maintain and
update information on how many symbols have been extracted and how many more
are left to extract. Nevertheless, in the name of optimization, this is
exactly what we now proceed to do.

We maintain two variables that describe the state of the two-frame block
\emph{outside} of the timing synchronizer at any given point in time. The first
is \verb+num_left_to_search+, which denotes the number of symbols that are
present in the two-frame block that have yet to be searched by the timing
synchronizer. The second is \verb+num_to_acquire+, which denotes the number of
symbols that have to be acquired from the complex data source in the current
iteration of the receive loop to fill the remainder of the buffer. While it is
redundant to maintain two variables, since we have
\verb|num_left_to_search + num_to_acquire = 2 * frame_size| but we do so for
the sake of convenience.

During initialization, both \verb+num_to_acquire+ and \verb+num_left_to_search+
are set to \verb+frame_size+. When the first frame is found, it will be found
somewhere in the middle of the two-frame block. Let this point in the two-frame
block be \verb+packet_loc+. As mentioned in \ref{subsec:safety}, the packet
location returned is after the preamble, but then \verb+safety+ positions to
the left. Thus, from \verb+packet_loc+, we can discard
\verb|frame_size - preamble_length + safety| number of symbols.

To make sure that we do not read symbols at the end of the frame, we assume
that there is some minimum distance between two frames. This distance is called
the \verb+frame_guard+. The number of symbols to discard, from
\verb+packet_loc+ onwards, is then
$\mathtt{frame\_size} - \mathtt{preamble\_length} + \mathtt{safety}
+ \mathtt{frame\_guard}$. In other words, the only relevant parameter, which is
the number of symbols that we still need to search through in the two-frame
block is
%TODO: Fix this equation
\begin{align}
	\mathtt{num\_left\_to\_search} &= 2 \times \mathtt{frame\_size}
                            - (\mathtt{frame\_size} - \mathtt{preamble\_length}
                                  + \mathtt{safety} + \mathtt{frame\_guard}) \\
         &= \mathtt{frame\_size} + \mathtt{preamble\_length}
									  - \mathtt{safety} - \mathtt{frame\_guard}
\end{align}

\verb+num_to_acquire+, which is the number of symbols that need to be acquired
in the next iteration of the receive loop is then
\verb|2 * frame_size - num_left_to_search|.

% TODO: Appendix on tuning the timing synchronizer
