\chapter{TIMING ANALYSIS}
\label{chap:timing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Packet detection}

Timing analysis is used to determine the point in time where the packet starts.
This is also a method to recognize \emph{whether} a packet has arrived or not.
In the current scheme, the packet detection module uses the Schmidl and Cox %(TODO: Put citation here)
method for timing analysis.

\subsection{The Schmidl and Cox algorithm}

For the receiver to be able to pick out a packet from ambient noise and
interference, the transmitted packet must be designed for detection. All
transmitted packets have a \emph{preamble}, which consists of two identical
halves. Each half is a pseudo-random-number sequence. The correlation of each
half with with other (independent and hence uncorrelated) signals is expected
to be low. However, its correlation with the other half will be high. Moreover,
this property is well-maintained even when the preamble is passed through an
ISI channel with additive white gaussian noise.

In other words, we can detect the start of a packet by correlating two adjacent
windows, each having half the size of the preamble, with each other. The point
where this correlation value becomes high can be taken to be the start of the
packet.

% TODO: Insert plot of preamble (real and imaginary) here
% TODO: Insert a picture of the two windows correlating received data

The metric used to determine whether or not the correlation value is high
enough is the normalized cross-correlation, defined as
$$ \text{Metric} = \frac{|\text{Cross-correlation of the two windows}|^2}
                        {\text{Product of the autocorrelations of the windows}}
$$

% TODO: Insert a picture of the metric over the data

\subsection{Running correlation on the receive buffer}

In order to efficiently perform a running correlation of adjacent windows over
an entire receive buffer, we minimize the number of computations performed. On
moving one step, we add the latest correlation point and subtract the oldest
correlation point.

Let $\ue{x}$ and $\ue{y}$ be complex vectors corresponding to the symbols in
the left half-window and the right-half-window respectively. Let $n$ be the
half-window size. After moving one time step, let these windows be denoted by
the complex vectors $u$ and $v$ respectively.  We thus have $u_i = x_{i+1}$ and
$v_i = y_{i+1}$ for $i = {1, 2, \ldots n-1}$.

Let $c_{old}$ be the correlation of $x$ with $y$, and $c_{new}$ be the
correlation of $u$ with $v$. That is,
$$ c_{old} = \corr{\ue{x}}{\ue{y}} = \sum_1^n{\corr{x_i}{y_i}} $$
$$ c_{new} = \corr{\ue{u}}{\ue{v}} = \sum_1^n{\corr{u_i}{v_i}} $$
where $^*$ denotes complex conjugation. We can then write $c_{new}$ in terms of
$c_{old}$ as follows:
\begin{align}
	c_{new} &= \sum_1^{n-1}{\corr{u_i}{v_i}} + \corr{u_n}{v_n} \\
	        &= \sum_2^n{\corr{x_i}{y_i}} + \corr{u_n}{v_n} \\
	        &= \sum_1^n{\corr{x_i}{y_i}} - \corr{x_1}{y_1} + \corr{u_n}{v_n} \\
	        &= c_{old} - \corr{x_1}{y_1} + \corr{u_n}{v_n}
\end{align}

This way, once we have acquired the correlation of the first $n$ symbols, the
correlation of subsequent windows is an $\mathcal{O}(1)$ process.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The DC offset problem}

\subsection{Discovering the DC offset}
\subsection{Eliminating the DC offset}
\subsection{Running correlations with DC offset elimination}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Practical considerations}

\subsection{Cross-correlation cut-off for noisy regions}
\label{sec:cross-corr-cut-off}

We expect the absolute value of the cross-correlation of the two windows to be
much lower than the product of their autocorrelations. However, we found that
the value of the metric tended at times to be quite large, and even comparable
to the threshold used to determine the presence of a packet.

A possible reason for this might be the accumulation of errors due to the
running correlation algorithm being employed. In the regions of noise, both the
autocorrelation and cross-correlation values are low, however, random
fluctuations in the noise and in the error could sometimes cause them to become
roughly of the same order of magnitude.

In order to prevent erroneous packet detection in noisy regions, we introduced
a cut-off based on the absolute value of the cross-correlation. This cut-off
value must be empirically determined. If the absolute value of the
cross-correlation is less that the cut-off, we manually set the running
cross-correlation at the point to be zero, and skip all other checks for the
packet.

%TODO: Put pseudocode / actual code snippet here

\subsection{Violation of Cauchy-Schwarz inequality}

We discovered that at certain instances, for example when searching for the
preamble towards the end of a previous frame, the value of the metric exceeded
unity. In a strict mathematical sense, this is impossible, since
cross-correlation is an inner product operation, and the Cauchy-Schwarz
inequlity guarantees that
$$ \langle \ue{u}, \ue{v} \rangle ^2 \leqslant |\ue{u}||\ue{v}| $$
Nevertheless, the situation was observed. On closer inspection, we found that
at the edge of the frame, the values of the complex symbols dropped rapidly. In
such a situation, it took time for the cross-correlation value to settle (time
for the accumulated errors to diminish in comparison to the cross-correlation
value itself), whereas the autocorrelation values settled faster. This caused
the cross-correlation value to exceed the autocorrelation product, thus giving
a metric value greater than unity.

When checking for the preamble itself, we gave allowances for errors causing
the metric value to exceed unity. But in the situation described above, this
occurred with far larger deviations than we might expect due purely to floating
point error. In fact, the error was the accumulated error in the algorithm
itself. In such situations also, we manually set the cross-correlation value to
zero to avoid further propagation of this error.

%TODO: Insert code snippet

\subsection{Fine metric}

When searching for the preamble in the body of a previous frame, we sometimes
found that the value of the metric exceeded the threshold. Essentially, the
values of the complex symbols within the frame depends on the data being
transmitted. It might so happen that the data produces a short repeating
pattern of the same length as the preamble in the bulk of the frame. In such a
sitation, the timing synchronizer will erroneously detect a packet in the
middle of a frame.

This is because, so far, we have only correlated the first half of the preamble
with the second half in the received vector. We never correlated the received
symbols with the actual preamble values themselves (which are fixed, and thus
known at the receiver). It may not be possible to simply increase the threshold
until this stops happening, since the threshold value is determined by the
amount of noise in the system. %TODO: Insert ref to appendix with tuning.

To fix this issue, the fine metric is computed by correlating the first window
with the first half of the expected preamble. This is only done when the coarse
metric exceeds the threshold, since it is an expensive operation and since we
cannot use a running correlation algorithm to compute it. The fine metric value
has its own threshold, which is used as a second-pass for ensuring the presence
of an authentic preamble.

Note that even in the presence of an ISI channel, the fine metric will pick up
the most dominant channel tap. If $\ue{p}$ is the preamble vector and $\ue{h}$
is the channel, then the received preamble is
$$\ue{y} = \ue{p} * \ue{h}$$
This received vector is now correlated with the preamble itself, so that the
fine metric peaks at $\text{argmax}(\ue{h})$ with a peak value of
$\text{max}(\ue{h})$.

%TODO: Insert fine metric plot

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Further optimizations}

\subsection{Stopping correlation after threshold breach}
\subsection{Discarding the found frame block}

% TODO: Appendix on tuning the timing synchronizer
